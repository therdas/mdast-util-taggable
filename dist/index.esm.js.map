{"version":3,"file":"index.esm.js","sources":["../src/types.ts","../src/from-markdown.ts","../src/to-markdown.ts"],"sourcesContent":["export interface Options {\n  classes: Array<string>;\n  rules: Array<Rules>;\n  allowEmail?: boolean;\n}\n\nexport interface Rules {\n  marker: string;\n  type: string;\n  toUrl: (arg: string) => string;\n  classes: Array<string>;\n}\n\nexport const defaultOptions: Options = {\n  classes: [\"micromark-taggable\"],\n  rules: [\n    {\n      marker: \"#\",\n      type: \"tag\",\n      toUrl: (val) => `/tags/${val}`,\n      classes: [\"tag\"],\n    },\n    {\n      marker: \"@\",\n      type: \"mention\",\n      toUrl: (val) => `/users/${val}`,\n      classes: [\"mention\"],\n    },\n  ],\n  allowEmail: false,\n};\n","import * as unist from \"unist\";\nimport { type Token } from \"micromark-util-types\";\nimport {\n  type Extension,\n  type CompileContext,\n  type Handle,\n} from \"mdast-util-from-markdown\";\nimport { Data } from \"mdast\";\nimport { Options, defaultOptions, Rules } from \"./types\";\n\nexport interface InlineTaggableData {\n  marker: string;\n  type: string;\n  url: string;\n}\n\nexport interface InlineTaggableNode extends unist.Literal {\n  type: \"taggable\";\n  value: string;\n  data: Data & InlineTaggableData;\n}\n\ndeclare module \"mdast\" {\n  interface PhrasingContentMap {\n    inlineTaggableNode: InlineTaggableNode;\n  }\n\n  interface RootContentMap {\n    inlineTaggableNode: InlineTaggableNode;\n  }\n}\n\nfunction top<T>(stack: T[]) {\n  return stack.at(-1);\n}\n\nexport const fromMarkdown = function (\n  opts: Options = defaultOptions,\n): Extension {\n  if (!opts.allowEmail) opts.allowEmail = false;\n\n  const typeMap = new Map(\n    opts.rules.map((elem: Rules) => [elem.marker, elem.type]),\n  );\n  const funcMap = new Map(\n    opts.rules.map((elem: Rules) => [elem.marker, elem.toUrl]),\n  );\n\n  const enterInlineTaggable: Handle = function (\n    this: CompileContext,\n    token: Token,\n  ) {\n    this.enter(\n      {\n        type: \"taggable\",\n\n        //@ts-expect-error: known invalid item - will be populated on parse\n        value: null,\n        data: {\n          marker: null,\n          type: null,\n          url: null,\n        },\n      },\n      token,\n    );\n  };\n\n  const exitInlineTaggableMarker: Handle = function (\n    this: CompileContext,\n    token: Token,\n  ) {\n    const marker = this.sliceSerialize(token);\n    const currentNode = top(this.stack) as InlineTaggableNode;\n    currentNode.data.marker = marker;\n    currentNode.data.type = typeMap.get(marker)!; //Guaranteed to exist\n  };\n\n  const exitInlineTaggableValue: Handle = function (\n    this: CompileContext,\n    token: Token,\n  ) {\n    const node: InlineTaggableNode = top(this.stack) as InlineTaggableNode;\n    const value = this.sliceSerialize(token);\n    node.value = value;\n    node.data.url = funcMap.get(node.data.marker)!(value); //Guaranteed to exist\n  };\n\n  const exitInlineTaggable: Handle = function (\n    this: CompileContext,\n    token: Token,\n  ) {\n    this.exit(token);\n  };\n\n  return {\n    enter: {\n      taggable: enterInlineTaggable,\n    },\n    exit: {\n      taggableMarker: exitInlineTaggableMarker,\n      taggableValue: exitInlineTaggableValue,\n      taggable: exitInlineTaggable,\n    },\n  };\n};\n","import { InlineTaggableNode } from \"./from-markdown\";\nimport { defaultOptions, Options } from \"./types\";\nimport {\n  Handle,\n  Handlers,\n  State,\n  Unsafe,\n  ConstructName,\n} from \"mdast-util-to-markdown\";\nimport * as unist from \"unist\";\n\ndeclare module \"mdast-util-to-markdown\" {\n  interface ConstructNameMap {\n    taggable: \"taggable\";\n    taggableData: \"taggableData\";\n  }\n}\n\nexport { Options, defaultOptions };\n\nexport function toMarkdown(opts: Options = defaultOptions): {\n  handlers: Partial<Handlers>;\n  unsafe: Unsafe[];\n} {\n  if (!opts.allowEmail) opts.allowEmail = false;\n\n  const unsafe: Unsafe[] = opts.rules.flatMap((val) => {\n    return {\n      character: val.marker,\n      inConstruct: [\"taggable\" as ConstructName],\n    };\n  });\n\n  const handler: Handle = (\n    node: InlineTaggableNode,\n    _: unist.Parent | null | undefined,\n    context: State,\n  ) => {\n    const exit = context.enter(\"taggable\");\n    const str = node.data.marker + node.value;\n    exit();\n    return str;\n  };\n\n  return {\n    unsafe: unsafe,\n    handlers: {\n      taggable: handler as unknown as Handle,\n    },\n  };\n}\n"],"names":[],"mappings":"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"}